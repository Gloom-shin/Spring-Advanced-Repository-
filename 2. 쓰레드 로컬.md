# 스프링의 강의 리뷰📽

> LoadMap Part : 스프링 핵심원리 고급편   
> Section : 2.Thread Local  
> CreateDate : 2022.11.14   
> UpdateDate : 2022.11.

### 목차

<br></br>

### IntelliJ 단축키

<br></br>
<br></br>

# 필드 동기화 - 개발

> 파라미터로 넘기도록 구현해서 동기화는 성공했지만, 로그를 출력하는 모든 메서드에 `TreadId`파라미터를 추가해야되는 문제가 발생한다.  
> 파라미터로 넘기지 않고 이 문제를 해결할 수 있는 방법은 없을까

## LogTrace 인터페이스

- 인터페이스부터 시작하여 제대로된 로그 추적기를 만들어 보자
    - 로그추적기에 필요한, begin(), end(), exception()이 들어간다.

```java
public interface LogTrace {
    TraceStatus begin(String message);

    void end(TraceStatus status);

    void exception(TraceStatus status, Exception e);
}
```

## FieldLogTrace 구현체

- 파라미터를 넘기지 않아도 TraceId를 동기화 할 수 있는 구현체 이다.
    - 기존에 만들었던 프로토타입 HelloTraceV2랑 기본 메서드는 비슷하다.
    - [구현체 FieldLogTrace 코드](code/advanced/trace/logtrace/FieldLogTrace.java)
- 추가된 코드
   - 변수로 `TraceId`를 담는 `traceIdHolder`가 생겼다.
     - 이로인해, 파라미터로 넘겨주지않아도 된다.
   - `syncTraceId()` : 동기화 이슈 처리해주는 매서드, 기존꺼가 있으면 굳이 새로만들지 않고 +1 해준다.
   - `releaseTraceId()` : 동기화 이슈 처리해주는 매서드, level이 1이상이면 삭제하지않고 -1 해준다. 
```java
public class FieldLogTrace implements LogTrace {
  //..생략
    private TraceId traceIdHolder; // traceId 동기화,  동시성 이슈 발생

    @Override
    public TraceStatus begin(String message) {
        syncTraceId();
        TraceId traceId = traceIdHolder;
      //..생략
    }

    private void syncTraceId() {
        if (traceIdHolder == null) {
            traceIdHolder = new TraceId();
        } else
            traceIdHolder = traceIdHolder.createNextId();
    }

    private void complete(TraceStatus status, Exception e) {
        //..생략
        releaseTraceId(); //추가
    }


    private void releaseTraceId() {
        if (traceIdHolder.isFirstLevel()) {
            traceIdHolder = null; // destroy
        } else
            traceIdHolder = traceIdHolder.createPreviousId();
    }


}
```

### 테스트
```java
class FieldLogTraceTest {

  FieldLogTrace trace = new FieldLogTrace();

  @Test
  void begin_end_level2() {
    TraceStatus status1 = trace.begin("hello1");
    TraceStatus status2 = trace.begin("hello2");
    trace.end(status2);
    trace.end(status1);
  }

  @Test
  void begin_exception_level2() {
    TraceStatus status1 = trace.begin("hello1");
    TraceStatus status2 = trace.begin("hello2");
    trace.exception(status2, new IllegalStateException());
    trace.exception(status1, new IllegalStateException());
  }
}
```
 - 확인 결과 깔끔하게 잘 나온다.

<img src="https://user-images.githubusercontent.com/104331549/201832905-aaca38e6-5ddd-4807-8bb6-c938b9647471.png">


<br>
<br>

# app적용
 - [로그추적기V3 컨트롤러](code/advanced/app/v3/OrderControllerV3.java)
 - [로그추적기V3 서비스](code/advanced/app/v3/OrderServiceV3.java)
 - [로그추적기V3 리포지토리](code/advanced/app/v3/OrderRepositoryV3.java)
 
> 하지만 이럴 경우, 동시성 문제가 발생한다. 


<br>
<br>

# 동시성 문제
 - 심각한 동시성문제를 가지고있다. 호출을 여러번해보면 바로 확인할 수 있다.
 - 애플리케이션 실행 후 빠르게 호출을 2번하니 아래와 같이 나왔다.
<img src="https://user-images.githubusercontent.com/104331549/201837596-a10f0bde-6cb9-4eb0-9dcd-59a876399ed4.png">

 - 두개의 쓰레드를 사용해 로그 추적기를 실행했지만,
   - 트랜잭션 ID는 두개의 호출다 동일했으며, 
   - level도 중첩되어서, 깊이가 이상하게 출력됨을 볼 수 있다. 

## 동시성 문제 원인
 - `FieldLogTrace` 는 싱글톤으로 등록된 스프링 빈이다
   - 객체의 인스턴스가 애플리케이션에 딱 1 개만 존재한다는 뜻이다.
 - 이렇게 하나만 있는 인스턴스의 `FieldLogTrace.traceIdHolder` 필드를 여러 쓰레드가 동시에 접근하기 때문에 문제가 발생한다